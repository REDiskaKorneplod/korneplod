ООП (Объектно-ориентированное программирование) в Python — это парадигма, основанная на создании программ как набора взаимодействующих объектов, каждый из которых является экземпляром класса. Классы служат шаблонами для создания объектов, которые имеют атрибуты (данные) и методы (поведение). Основные принципы ООП в Python включают наследование (создание новых классов на основе существующих), инкапсуляцию (скрытие данных) и полиморфизм (возможность объектов разного типа реагировать на один и тот же вызов по-разному).
### основные концепции
- **Класс:**    
	Шаблон или "чертеж" для создания объектов. Он определяет структуру (атрибуты) и
поведение (методы). 
- **Объект:** 
	Экземпляр класса, который имеет свое состояние (значения атрибутов) и может выполнять действия (вызывать методы). Например, `cat1` и `cat2` могут быть объектами класса `Cat`. 
- **Атрибут:** 
	Переменная, связанная с объектом, которая хранит его данные. Например, у объекта "кошка" могут быть атрибуты: `имя`, `возраст` или `цвет`. 
- **Метод:** 
	Функция, связанная с классом, которая определяет, что объект может делать. Например, метод `мяукать()` или `спать()` для объекта "кошка".
### ключевые принципы и примеры
-  Инкапсуляция
	Все объекты в Python инкапсулируют внутри себя данные и методы работы с ними, предоставляя публичные интерфейсы для взаимодействия.
		```Python
	class SomeClass:
    def _private(self):
        print("Это внутренний метод объекта")
	
	obj = SomeClass()
	obj._private() # это внутренний метод объекта
		```
- Наследование
	Используя множественное наследования можно создавать классы-миксины (примеси), представляющие собой определенную особенность поведения. Такой микси можно "примешать" к любому классу.
		```Python
	class Horse():
    isHorse = True
	
	class Donkey():
    isDonkey = True
	
	class Mule(Horse, Donkey):
	mule = Mule()
	mule.isHorse # True
	mule.isDonkey # True
- Ассоциация
	Ассоциированные объекты могут циклически ссылаться друг на друга, что ломает стандартный механизм сборки мусора. Избежать подобных проблем при ассоциации помогают слабые ссылки (модуль `weakref`).
		```Python
	class Salary:
    def __init__(self,pay):
        self.pay = pay
	
    def getTotal(self):
        return (self.pay*12)
	
	class Employee:
    def __init__(self,pay,bonus):
        self.pay = pay
        self.bonus = bonus
        self.salary = Salary(self.pay)
	
    def annualSalary(self):
        return "Total: " + str(self.salary.getTotal() + self.bonus)
	
	employee = Employee(100,10)
	print(employee.annualSalary())
- Полиморфизм
	Все методы в языке изначально виртуальные. Это значит, что дочерние классы могут их переопределять и решать одну и ту же задачу разными путями, а конкретная реализация будет выбрана только во время исполнения программы. Такие классы называют полиморфными.
		```Python
	class Mammal:
    def move(self):
        print('Двигается')
	
	class Hare(Mammal):
    def move(self):
        print('Прыгает')
	
	animal = Mammal()
	animal.move() # Двигается
	hare = Hare()
	hare.move() # Прыгает
